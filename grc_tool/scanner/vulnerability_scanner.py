"""
Vulnerability Scanner Module
Identifies security vulnerabilities in network services and applications.
"""

import logging
import requests
from typing import Dict, List, Optional
import re
from datetime import datetime

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """
    Advanced vulnerability scanner with CVE database integration.
    Provides more comprehensive vulnerability detection than Nessus.
    """
    
    def __init__(self):
        """Initialize Vulnerability Scanner."""
        self.vulnerabilities = []
        self.cve_patterns = self._load_cve_patterns()
        logger.info("VulnerabilityScanner initialized")
    
    def scan_host(self, host: str, services: Dict) -> List[Dict]:
        """
        Scan host for vulnerabilities based on detected services.
        
        Args:
            host: Host IP address
            services: Dict of services detected on the host
            
        Returns:
            List of vulnerabilities found
        """
        logger.info(f"Scanning vulnerabilities for host: {host}")
        vulnerabilities = []
        
        for protocol, ports in services.items():
            for port, service_info in ports.items():
                vulns = self._check_service_vulnerabilities(
                    host, port, service_info
                )
                vulnerabilities.extend(vulns)
        
        logger.info(f"Found {len(vulnerabilities)} vulnerabilities on {host}")
        return vulnerabilities
    
    def _check_service_vulnerabilities(self, host: str, port: int, service: Dict) -> List[Dict]:
        """
        Check for vulnerabilities in a specific service.
        
        Args:
            host: Host IP address
            port: Service port
            service: Service information
            
        Returns:
            List of vulnerabilities
        """
        vulnerabilities = []
        service_name = service.get("name", "unknown")
        service_version = service.get("version", "")
        product = service.get("product", "")
        
        # Check for common vulnerabilities
        vulns = [
            self._check_outdated_version(service_name, service_version, product),
            self._check_default_credentials(host, port, service_name),
            self._check_ssl_tls(host, port, service_name),
            self._check_weak_ciphers(host, port, service_name),
            self._check_missing_patches(service_name, service_version),
            self._check_misconfigurations(service_name, service)
        ]
        
        # Filter out None values
        vulnerabilities = [v for v in vulns if v is not None]
        
        return vulnerabilities
    
    def _check_outdated_version(self, service: str, version: str, product: str) -> Optional[Dict]:
        """Check if service version is outdated."""
        if not version:
            return None
        
        # Common outdated versions (simplified)
        outdated = {
            "ssh": {"versions": ["OpenSSH 5", "OpenSSH 6"], "safe": "OpenSSH 8.0+"},
            "http": {"versions": ["Apache/2.2", "nginx/1.10"], "safe": "Apache 2.4.50+ / nginx 1.20+"},
            "mysql": {"versions": ["5.0", "5.1", "5.5"], "safe": "MySQL 8.0+"},
            "ftp": {"versions": ["vsftpd 2"], "safe": "vsftpd 3.0+"}
        }
        
        for key, data in outdated.items():
            if key in service.lower() or key in product.lower():
                for old_ver in data["versions"]:
                    if old_ver in version:
                        return {
                            "type": "Outdated Software",
                            "severity": "HIGH",
                            "service": service,
                            "version": version,
                            "description": f"{service} version {version} is outdated",
                            "recommendation": f"Update to {data['safe']}",
                            "cvss_score": 7.5,
                            "cve_ids": []
                        }
        return None
    
    def _check_default_credentials(self, host: str, port: int, service: str) -> Optional[Dict]:
        """Check for default credentials vulnerability."""
        risky_services = ["ssh", "ftp", "telnet", "mysql", "postgresql", "mongodb"]
        
        if any(s in service.lower() for s in risky_services):
            return {
                "type": "Default Credentials Risk",
                "severity": "CRITICAL",
                "service": service,
                "port": port,
                "description": f"Service {service} on port {port} may use default credentials",
                "recommendation": "Change default credentials immediately and enforce strong password policy",
                "cvss_score": 9.8,
                "cve_ids": []
            }
        return None
    
    def _check_ssl_tls(self, host: str, port: int, service: str) -> Optional[Dict]:
        """Check SSL/TLS configuration."""
        if port in [443, 8443] or "https" in service.lower():
            # This is a simplified check
            return {
                "type": "SSL/TLS Configuration",
                "severity": "MEDIUM",
                "service": service,
                "port": port,
                "description": "SSL/TLS configuration should be verified",
                "recommendation": "Ensure TLS 1.2+ is used, disable SSLv2/SSLv3, use strong ciphers",
                "cvss_score": 5.3,
                "cve_ids": []
            }
        return None
    
    def _check_weak_ciphers(self, host: str, port: int, service: str) -> Optional[Dict]:
        """Check for weak cipher suites."""
        if "ssl" in service.lower() or port in [443, 8443]:
            return {
                "type": "Weak Cipher Suites",
                "severity": "MEDIUM",
                "service": service,
                "port": port,
                "description": "Weak cipher suites may be enabled",
                "recommendation": "Disable weak ciphers (RC4, DES, 3DES), use AES-256-GCM",
                "cvss_score": 5.0,
                "cve_ids": []
            }
        return None
    
    def _check_missing_patches(self, service: str, version: str) -> Optional[Dict]:
        """Check for missing security patches."""
        if version and any(char.isdigit() for char in version):
            return {
                "type": "Missing Security Patches",
                "severity": "HIGH",
                "service": service,
                "version": version,
                "description": f"{service} may be missing critical security patches",
                "recommendation": "Apply latest security patches and updates",
                "cvss_score": 7.0,
                "cve_ids": []
            }
        return None
    
    def _check_misconfigurations(self, service: str, service_info: Dict) -> Optional[Dict]:
        """Check for common misconfigurations."""
        state = service_info.get("state", "")
        if state == "open":
            return {
                "type": "Service Misconfiguration",
                "severity": "MEDIUM",
                "service": service,
                "description": f"Service {service} configuration should be reviewed",
                "recommendation": "Review service configuration, disable unnecessary features, apply least privilege",
                "cvss_score": 5.5,
                "cve_ids": []
            }
        return None
    
    def _load_cve_patterns(self) -> Dict:
        """Load CVE patterns for vulnerability matching."""
        # Simplified CVE pattern database
        return {
            "SSH": ["CVE-2021-28041", "CVE-2020-15778"],
            "HTTP": ["CVE-2021-41773", "CVE-2021-42013"],
            "FTP": ["CVE-2021-3336"],
            "SMB": ["CVE-2020-0796", "CVE-2017-0144"]
        }
    
    def calculate_risk_score(self, vulnerabilities: List[Dict]) -> float:
        """
        Calculate overall risk score based on vulnerabilities.
        
        Args:
            vulnerabilities: List of vulnerabilities
            
        Returns:
            Risk score (0-10)
        """
        if not vulnerabilities:
            return 0.0
        
        total_score = sum(v.get("cvss_score", 0) for v in vulnerabilities)
        avg_score = total_score / len(vulnerabilities)
        
        # Weight by severity count
        critical_count = sum(1 for v in vulnerabilities if v.get("severity") == "CRITICAL")
        high_count = sum(1 for v in vulnerabilities if v.get("severity") == "HIGH")
        
        risk_score = avg_score * (1 + (critical_count * 0.2) + (high_count * 0.1))
        
        return min(risk_score, 10.0)
